#!/usr/bin/env php
<?php

use Tivins\LSP\LiskovSubstitutionPrincipleChecker;
use Tivins\LSP\ThrowsDetector;
use Tivins\Process\ClassFinder;
use Tivins\Process\FormatType;
use Tivins\Process\StdWriter;

# Load autoload.php from the root project
$autoload = 'vendor/autoload.php';
if (!is_file($autoload)) {
    throw new Exception('"vendor/autoload.php" not found. Current directory: ' . __dir__);
}
require $autoload;

// --- CLI options -----------------------------------------------------------

$format = FormatType::TEXT;
if (in_array('--json', $argv)) {
    $format = FormatType::JSON;
}
$verbose = !in_array('--quiet', $argv);

// First non-option argument = directory to scan.
$directory = null;
foreach (array_slice($argv, 1) as $arg) {
    if (!str_starts_with($arg, '--')) {
        $directory = $arg;
        break;
    }
}

if ($directory === null) {
    fwrite(STDERR, "Usage: lsp-checker <directory> [--json] [--quiet]\n");
    fwrite(STDERR, "  <directory>  Path to a directory containing PHP files to check.\n");
    fwrite(STDERR, "  --json       Output violations as JSON.\n");
    fwrite(STDERR, "  --quiet      Minimal output.\n");
    fwrite(STDERR, "\nRun unit tests with: vendor/bin/phpunit\n");
    exit(2);
}

if (!is_dir($directory)) {
    fwrite(STDERR, "Error: '$directory' is not a valid directory.\n");
    exit(2);
}

# --- Main program -----------------------------------------------------------

$finder  = new ClassFinder();
$classes = $finder->findClassesInDirectory($directory);
if (empty($classes)) {
    fwrite(STDERR, "No PHP classes found in '$directory'.\n");
    exit(0);
}

$writer = new StdWriter($verbose, $format);
$checker = new LiskovSubstitutionPrincipleChecker(new ThrowsDetector());
$writer->message("Checking Liskov Substitution Principle...", "\n\n");

$totalViolations = 0;
$failedClasses = 0;
$allViolations = [];
$allErrors = [];

foreach ($classes as $class) {

    $loadError = null;
    try {
        $violations = $checker->check($class);
    } catch (ReflectionException $e) {
        $violations = [];
        $loadError = $e->getMessage();
    }

    $ok = ($loadError === null && count($violations) === 0);
    $writer->content(($ok ? "[PASS]" : "[FAIL]") . " $class", FormatType::TEXT);

    if (!$ok) {
        $failedClasses++;
        if ($loadError !== null) {
            $allErrors[] = ['class' => $class, 'message' => $loadError];
            $writer->content("       -> Error: $loadError", FormatType::TEXT);
        } else {
            $totalViolations += count($violations);
            $allViolations = array_merge($allViolations, $violations);
            foreach ($violations as $violation) {
                $writer->content("       -> $violation", FormatType::TEXT);
            }
        }
    }
}

$writer->message("");
$writer->message("Classes checked: " . count($classes));
$writer->message("Passed: " . (count($classes) - $failedClasses) . " / " . count($classes));
$writer->message("Total violations: $totalViolations");

$jsonReport = [
    'violations' => $allViolations,
    'errors' => $allErrors,
];
$writer->content(json_encode($jsonReport, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES), FormatType::JSON);

// Exit with code 1 if there were any failures, 0 otherwise.
exit($failedClasses > 0 ? 1 : 0);
